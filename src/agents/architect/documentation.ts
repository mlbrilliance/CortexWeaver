/**
 * Architect Agent Documentation Management
 * 
 * Contains functionality for creating and formatting design documentation
 */

import * as path from 'path';
import { Agent } from '../../agent';
import { ArchitecturalAnalysis, FormalContracts, ContractCompliance } from './types';

export class ArchitectDocumentation {
  constructor(private agent: Agent) {}

  /**
   * Create design documentation files in the worktree
   */
  async createDesignDocumentation(analysis: ArchitecturalAnalysis): Promise<void> {
    const currentTask = this.agent.getCurrentTask();
    if (!currentTask) {
      throw new Error('No current task available');
    }

    try {
      // Get worktree path
      const workspace = this.agent.getWorkspace();
      const config = this.agent.getConfig();
      const worktreePath = workspace?.getWorktreePath(currentTask.id) || config?.workspaceRoot || '';
      const designFilePath = path.join(worktreePath, 'DESIGN.md');

      // Create comprehensive design document
      const designContent = this.formatDesignDocument(analysis);

      // Write DESIGN.md file
      await this.agent.writeFile('DESIGN.md', designContent);

      // Create additional files if API spec or data models are significant
      if (analysis.apiSpec.length > 100) {
        await this.agent.writeFile('api-spec.yaml', analysis.apiSpec);
      }

      if (Object.keys(analysis.dataModels).length > 1) {
        await this.agent.writeFile('data-models.json', JSON.stringify(analysis.dataModels, null, 2));
      }

    } catch (error) {
      throw new Error(`Failed to create design documentation: ${(error as Error).message}`);
    }
  }

  /**
   * Format the complete design document
   */
  private formatDesignDocument(analysis: ArchitecturalAnalysis): string {
    const timestamp = new Date().toISOString();
    const currentTask = this.agent.getCurrentTask();
    const taskTitle = currentTask?.title || 'Architectural Design';
    const taskContext = this.agent.getTaskContext();
    const formalContracts = (taskContext as any)?.formalContracts as FormalContracts;

    let document = `# Architectural Design: ${taskTitle}

*Generated on: ${timestamp}*
*Task ID: ${currentTask?.id}*
${formalContracts ? '*Contract-Driven Design: Yes*' : ''}

## Overview

${analysis.designDocument}

## Mermaid Diagrams

${analysis.mermaidDiagram}

## API Specifications

${analysis.apiSpec}

## Data Models

\`\`\`json
${JSON.stringify(analysis.dataModels, null, 2)}
\`\`\`

## Architectural Decisions

${analysis.decisions.map(decision => `
### ${decision.title}

**Description:** ${decision.description}

**Rationale:** ${decision.rationale}

${decision.alternatives && decision.alternatives.length > 0 ? `**Alternatives:** ${decision.alternatives.join(', ')}` : ''}

${decision.consequences && decision.consequences.length > 0 ? `**Consequences:** ${decision.consequences.join(', ')}` : ''}
`).join('\n')}`;

    // Add contract compliance section if available
    if (analysis.contractCompliance) {
      document += this.formatContractComplianceSection(analysis.contractCompliance, formalContracts!);
    }

    document += `

---
*This document was generated by the CortexWeaver Architect Agent.*
`;

    return document;
  }

  /**
   * Format contract compliance section for the design document
   */
  private formatContractComplianceSection(compliance: ContractCompliance, contracts: FormalContracts): string {
    let section = `

## Contract Compliance Analysis

**Overall Compliance Score: ${(compliance.overallScore * 100).toFixed(1)}%**

`;

    if (compliance.openApiCompliance.length > 0) {
      section += `### OpenAPI Specification Compliance

`;
      compliance.openApiCompliance.forEach(apiComp => {
        section += `#### ${apiComp.specPath}
`;
        section += `- **Compliance Score:** ${(apiComp.complianceScore * 100).toFixed(1)}%\n`;
        section += `- **Endpoints Covered:** ${apiComp.endpointsCovered.length > 0 ? apiComp.endpointsCovered.join(', ') : 'None'}\n`;
        if (apiComp.missingEndpoints.length > 0) {
          section += `- **Missing Endpoints:** ${apiComp.missingEndpoints.join(', ')}\n`;
        }
        section += `\n`;
      });
    }

    if (compliance.schemaCompliance.length > 0) {
      section += `### JSON Schema Compliance

`;
      compliance.schemaCompliance.forEach(schemaComp => {
        section += `#### ${schemaComp.schemaPath}
`;
        section += `- **Compliance Score:** ${(schemaComp.complianceScore * 100).toFixed(1)}%\n`;
        section += `- **Models Aligned:** ${schemaComp.modelsAligned.length > 0 ? schemaComp.modelsAligned.join(', ') : 'None'}\n`;
        if (schemaComp.missingModels.length > 0) {
          section += `- **Missing Models:** ${schemaComp.missingModels.join(', ')}\n`;
        }
        section += `\n`;
      });
    }

    // Add recommendations for improvement
    const lowComplianceItems = [
      ...compliance.openApiCompliance.filter(comp => comp.complianceScore < 0.8),
      ...compliance.schemaCompliance.filter(comp => comp.complianceScore < 0.8)
    ];

    if (lowComplianceItems.length > 0) {
      section += `### Recommendations for Improvement

`;
      section += `The following contract files have compliance scores below 80% and may need attention:\n\n`;
      lowComplianceItems.forEach(item => {
        const path = 'specPath' in item ? item.specPath : item.schemaPath;
        section += `- **${path}**: Consider reviewing the design to ensure all contract requirements are addressed\n`;
      });
    }

    return section;
  }
}